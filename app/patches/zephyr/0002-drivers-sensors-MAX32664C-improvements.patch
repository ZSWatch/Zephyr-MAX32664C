From 3b9d35e5ef831df7e792608594431d49c50a9290 Mon Sep 17 00:00:00 2001
From: Daniel Kampert <DanielKampert@kampis-elektroecke.de>
Date: Thu, 16 Oct 2025 15:02:57 +0200
Subject: [PATCH 2/2] drivers: sensors: MAX32664C improvements

- Add function to read the firmware version
- Fix broken SCD sensor reading
- Add SCD mode to worker
- Add activity class to sensor readings
- The algorithm mode can now be read by attr_get API
- Add status attribute for the driver
- Add configuration option for LED mapping

Signed-off-by: Daniel Kampert <DanielKampert@kampis-elektroecke.de>
---
 .../adi/max32664c/Driver Improvements.md      |   9 +
 drivers/sensor/adi/max32664c/max32664c.c      | 212 +++++++++++++-----
 drivers/sensor/adi/max32664c/max32664c.h      |   6 +-
 drivers/sensor/adi/max32664c/max32664c_bl.c   |   8 +-
 drivers/sensor/adi/max32664c/max32664c_init.c |  15 +-
 .../sensor/adi/max32664c/max32664c_worker.c   |  26 ++-
 dts/bindings/sensor/maxim,max32664c.yml       |  13 +-
 7 files changed, 217 insertions(+), 72 deletions(-)
 create mode 100644 drivers/sensor/adi/max32664c/Driver Improvements.md

diff --git a/drivers/sensor/adi/max32664c/Driver Improvements.md b/drivers/sensor/adi/max32664c/Driver Improvements.md
new file mode 100644
index 00000000000..297e511e65b
--- /dev/null
+++ b/drivers/sensor/adi/max32664c/Driver Improvements.md	
@@ -0,0 +1,9 @@
+# Driver improvements
+
+Open points for the driver:
+
+- Make the sampling time adjustable through the API
+- Make the integration time adjustable through the API
+- Set the LED current
+- Add support for interrupts
+- Add support for LED config
diff --git a/drivers/sensor/adi/max32664c/max32664c.c b/drivers/sensor/adi/max32664c/max32664c.c
index 99d89cc655b..7123358cff5 100644
--- a/drivers/sensor/adi/max32664c/max32664c.c
+++ b/drivers/sensor/adi/max32664c/max32664c.c
@@ -51,6 +51,46 @@ int max32664c_i2c_transmit(const struct device *dev, uint8_t *tx_buf, uint8_t tx
 	return 0;
 }
 
+int max32664c_read_fw_version(const struct device *dev, uint8_t *major, uint8_t *minor,
+				     uint8_t *patch)
+{
+	uint8_t rx_buf[4] = {0};
+	uint8_t tx[2];
+
+	/* Read the firmware version */
+	tx[0] = 0xFF;
+	tx[1] = 0x03;
+	if (max32664c_i2c_transmit(dev, tx, 2, rx_buf, 4, MAX32664C_DEFAULT_CMD_DELAY)) {
+		return -EINVAL;
+	}
+
+	*major = rx_buf[1];
+	*minor = rx_buf[2];
+	*patch = rx_buf[3];
+
+	return 0;
+}
+
+int max32664c_read_fw_version(const struct device *dev, uint8_t *major, uint8_t *minor,
+				     uint8_t *patch)
+{
+	uint8_t rx_buf[4] = {0};
+	uint8_t tx[2];
+
+	/* Read the firmware version */
+	tx[0] = 0xFF;
+	tx[1] = 0x03;
+	if (max32664c_i2c_transmit(dev, tx, 2, rx_buf, 4, MAX32664C_DEFAULT_CMD_DELAY)) {
+		return -EINVAL;
+	}
+
+	*major = rx_buf[1];
+	*minor = rx_buf[2];
+	*patch = rx_buf[3];
+
+	return 0;
+}
+
 /** @brief      Check the accelerometer and AFE WHOAMI registers.
  *              This function is called during device initialization.
  *  @param dev  Pointer to device
@@ -124,7 +164,7 @@ static int max32664c_stop_algo(const struct device *dev)
 	uint8_t tx[3];
 	struct max32664c_data *data = dev->data;
 
-	if (data->op_mode == MAX32664C_OP_MODE_IDLE) {
+	if (data->device_mode == MAX32664C_OP_MODE_IDLE) {
 		LOG_DBG("No algorithm running, nothing to stop.");
 		return 0;
 	}
@@ -139,7 +179,7 @@ static int max32664c_stop_algo(const struct device *dev)
 		return -EINVAL;
 	}
 
-	switch (data->op_mode) {
+	switch (data->device_mode) {
 	case MAX32664C_OP_MODE_RAW: {
 #ifndef CONFIG_MAX32664C_USE_STATIC_MEMORY
 		k_msgq_cleanup(&data->raw_report_queue);
@@ -170,12 +210,12 @@ static int max32664c_stop_algo(const struct device *dev)
 		break;
 	}
 	default: {
-		LOG_ERR("Unknown algorithm mode: %d", data->op_mode);
+		LOG_ERR("Unknown device mode: %d", data->device_mode);
 		return -EINVAL;
 	}
 	};
 
-	data->op_mode = MAX32664C_OP_MODE_IDLE;
+	data->device_mode = MAX32664C_OP_MODE_IDLE;
 
 	k_thread_suspend(data->thread_id);
 
@@ -232,17 +272,17 @@ static int max32664c_set_mode_raw(const struct device *dev)
 	}
 
 	/* Set the LED current */
-	for (uint8_t i = 0; i < sizeof(data->led_current); i++) {
-		tx[0] = 0x40;
-		tx[1] = 0x00;
-		tx[2] = 0x23 + i;
-		tx[3] = data->led_current[i];
-		LOG_INF("Set LED%d current: %u", i + 1, data->led_current[i]);
-		if (max32664c_i2c_transmit(dev, tx, 4, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
-			LOG_ERR("Can not set LED%d current", i + 1);
-			return -EINVAL;
-		}
-	}
+	//for (uint8_t i = 0; i < sizeof(data->led_current); i++) {
+	//	tx[0] = 0x40;
+	//	tx[1] = 0x00;
+	//	tx[2] = 0x23 + i;
+	//	tx[3] = data->led_current[i];
+	//	LOG_INF("Set LED%d current: %u", i + 1, data->led_current[i]);
+	//	if (max32664c_i2c_transmit(dev, tx, 4, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
+	//		LOG_ERR("Can not set LED%d current", i + 1);
+	//		return -EINVAL;
+	//	}
+	//}
 
 #ifndef CONFIG_MAX32664C_USE_STATIC_MEMORY
 	if (k_msgq_alloc_init(&data->raw_report_queue, sizeof(struct max32664c_raw_report_t),
@@ -252,7 +292,7 @@ static int max32664c_set_mode_raw(const struct device *dev)
 	}
 #endif /* CONFIG_MAX32664C_USE_STATIC_MEMORY */
 
-	data->op_mode = MAX32664C_OP_MODE_RAW;
+	data->device_mode = MAX32664C_OP_MODE_RAW;
 
 	k_thread_resume(data->thread_id);
 
@@ -278,6 +318,7 @@ static int max32664c_set_mode_algo(const struct device *dev, enum max32664c_devi
 		LOG_ERR("Failed to stop the algorithm!");
 		return -EINVAL;
 	}
+	data->algo_mode = algo_mode;
 
 	LOG_DBG("Entering algorithm mode...");
 
@@ -288,13 +329,16 @@ static int max32664c_set_mode_algo(const struct device *dev, enum max32664c_devi
 	}
 #endif /* CONFIG_MAX32664C_USE_EXTENDED_REPORTS */
 
-	/* Set the output mode to sensor and algorithm data */
+	/* Set the FIFO mode to sensor and algorithm data */
 	tx[0] = 0x10;
 	tx[1] = 0x00;
 	tx[2] = MAX32664C_OUT_ALGO_AND_SENSOR;
 	if (max32664c_i2c_transmit(dev, tx, 3, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
 		return -EINVAL;
 	}
+	data->algo_mode = algo_mode;
+
+	LOG_DBG("Algo mode: %u", algo_mode);
 
 	/* Set the algorithm mode */
 	tx[0] = 0x50;
@@ -304,6 +348,7 @@ static int max32664c_set_mode_algo(const struct device *dev, enum max32664c_devi
 	if (max32664c_i2c_transmit(dev, tx, 4, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
 		return -EINVAL;
 	}
+	data->algo_mode = algo_mode;
 
 	if (device_mode == MAX32664C_OP_MODE_ALGO_AEC) {
 		LOG_DBG("Entering AEC mode...");
@@ -336,28 +381,28 @@ static int max32664c_set_mode_algo(const struct device *dev, enum max32664c_devi
 			return -EINVAL;
 		}
 
-		data->op_mode = MAX32664C_OP_MODE_ALGO_AEC;
+		data->device_mode = MAX32664C_OP_MODE_ALGO_AEC;
 
 		if (extended) {
-			data->op_mode = MAX32664C_OP_MODE_ALGO_AEC_EXT;
+			data->device_mode = MAX32664C_OP_MODE_ALGO_AEC_EXT;
 		}
 	} else if (device_mode == MAX32664C_OP_MODE_ALGO_AGC) {
 		LOG_DBG("Entering AGC mode...");
 
 		/* TODO: Test if this works */
 		/* Set the LED current */
-		for (uint8_t i = 0; i < sizeof(data->led_current); i++) {
-			tx[0] = 0x40;
-			tx[1] = 0x00;
-			tx[2] = 0x23 + i;
-			tx[3] = data->led_current[i];
-			LOG_INF("Set LED%d current: %u", i + 1, data->led_current[i]);
-			if (max32664c_i2c_transmit(dev, tx, 4, &rx, 1,
-						   MAX32664C_DEFAULT_CMD_DELAY)) {
-				LOG_ERR("Can not set LED%d current", i + 1);
-				return -EINVAL;
-			}
-		}
+		//for (uint8_t i = 0; i < sizeof(data->led_current); i++) {
+		//	tx[0] = 0x40;
+		//	tx[1] = 0x00;
+		//	tx[2] = 0x23 + i;
+		//	tx[3] = data->led_current[i];
+		//	LOG_INF("Set LED%d current: %u", i + 1, data->led_current[i]);
+		//	if (max32664c_i2c_transmit(dev, tx, 4, &rx, 1,
+		//				   MAX32664C_DEFAULT_CMD_DELAY)) {
+		//		LOG_ERR("Can not set LED%d current", i + 1);
+		//		return -EINVAL;
+		//	}
+		//}
 
 		/* Enable AEC */
 		tx[0] = 0x50;
@@ -388,30 +433,32 @@ static int max32664c_set_mode_algo(const struct device *dev, enum max32664c_devi
 
 		/* Set AGC target PD current to 10 uA */
 		/* TODO: Add setting of PD current via API or DT? */
-		tx[0] = 0x50;
-		tx[1] = 0x07;
-		tx[2] = 0x11;
-		tx[3] = 0x00;
-		tx[4] = 0x64;
-		if (max32664c_i2c_transmit(dev, tx, 5, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
-			return -EINVAL;
-		}
+		//tx[0] = 0x50;
+		//tx[1] = 0x07;
+		//tx[2] = 0x11;
+		//tx[3] = 0x00;
+		//tx[4] = 0x64;
+		//if (max32664c_i2c_transmit(dev, tx, 5, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
+		//	return -EINVAL;
+		//}
 
-		data->op_mode = MAX32664C_OP_MODE_ALGO_AGC;
+		data->device_mode = MAX32664C_OP_MODE_ALGO_AGC;
 
 		if (extended) {
-			data->op_mode = MAX32664C_OP_MODE_ALGO_AGC_EXT;
+			data->device_mode = MAX32664C_OP_MODE_ALGO_AGC_EXT;
 		}
 	} else {
 		LOG_ERR("Invalid mode!");
 		return -EINVAL;
 	}
+	data->algo_mode = algo_mode;
 
 	/* Enable HR and SpO2 algorithm */
 	tx[2] = 0x01;
 	if (extended) {
 		tx[2] = 0x02;
 	}
+	data->algo_mode = algo_mode;
 
 	tx[0] = 0x52;
 	tx[1] = 0x07;
@@ -498,7 +545,7 @@ static int max32664c_set_mode_scd(const struct device *dev)
 	}
 #endif /* CONFIG_MAX32664C_USE_STATIC_MEMORY */
 
-	data->op_mode = MAX32664C_OP_MODE_SCD;
+	data->device_mode = MAX32664C_OP_MODE_SCD;
 
 	k_thread_resume(data->thread_id);
 
@@ -546,7 +593,7 @@ static int max32664c_set_mode_wake_on_motion(const struct device *dev)
 		return -EINVAL;
 	}
 
-	data->op_mode = MAX32664C_OP_MODE_WAKE_ON_MOTION;
+	data->device_mode = MAX32664C_OP_MODE_WAKE_ON_MOTION;
 
 	return 0;
 }
@@ -575,7 +622,7 @@ static int max32664c_exit_mode_wake_on_motion(const struct device *dev)
 		return -EINVAL;
 	}
 
-	data->op_mode = MAX32664C_OP_MODE_IDLE;
+	data->device_mode = MAX32664C_OP_MODE_IDLE;
 
 	return 0;
 }
@@ -613,7 +660,7 @@ static int max32664c_disable_sensors(const struct device *dev)
 		return -EINVAL;
 	}
 
-	data->op_mode = MAX32664C_OP_MODE_IDLE;
+	data->device_mode = MAX32664C_OP_MODE_IDLE;
 
 	return 0;
 }
@@ -622,7 +669,7 @@ static int max32664c_sample_fetch(const struct device *dev, enum sensor_channel
 {
 	struct max32664c_data *data = dev->data;
 
-	switch (data->op_mode) {
+	switch (data->device_mode) {
 	case MAX32664C_OP_MODE_STOP_ALGO:
 	case MAX32664C_OP_MODE_IDLE:
 		LOG_DBG("Device is idle, no data to fetch!");
@@ -633,11 +680,13 @@ static int max32664c_sample_fetch(const struct device *dev, enum sensor_channel
 #ifdef CONFIG_MAX32664C_USE_EXTENDED_REPORTS
 	case MAX32664C_OP_MODE_ALGO_AEC_EXT:
 	case MAX32664C_OP_MODE_ALGO_AGC_EXT:
+		k_msgq_get(&data->raw_report_queue, &data->raw, K_NO_WAIT);
 		k_msgq_get(&data->ext_report_queue, &data->ext, K_NO_WAIT);
 		return 0;
 #else
 	case MAX32664C_OP_MODE_ALGO_AEC:
 	case MAX32664C_OP_MODE_ALGO_AGC:
+		k_msgq_get(&data->raw_report_queue, &data->raw, K_NO_WAIT);
 		k_msgq_get(&data->report_queue, &data->report, K_NO_WAIT);
 		return 0;
 #endif /* CONFIG_MAX32664C_USE_EXTENDED_REPORTS */
@@ -658,26 +707,32 @@ static int max32664c_channel_get(const struct device *dev, enum sensor_channel c
 	switch ((int)chan) {
 	case SENSOR_CHAN_ACCEL_X: {
 		val->val1 = data->raw.acc.x;
+		val->val2 = 0;
 		break;
 	}
 	case SENSOR_CHAN_ACCEL_Y: {
 		val->val1 = data->raw.acc.y;
+		val->val2 = 0;
 		break;
 	}
 	case SENSOR_CHAN_ACCEL_Z: {
 		val->val1 = data->raw.acc.z;
+		val->val2 = 0;
 		break;
 	}
 	case SENSOR_CHAN_GREEN: {
 		val->val1 = data->raw.PPG1;
+		val->val2 = data->raw.PPG4;
 		break;
 	}
 	case SENSOR_CHAN_IR: {
 		val->val1 = data->raw.PPG2;
+		val->val2 = data->raw.PPG5;
 		break;
 	}
 	case SENSOR_CHAN_RED: {
 		val->val1 = data->raw.PPG3;
+		val->val2 = data->raw.PPG6;
 		break;
 	}
 	case SENSOR_CHAN_MAX32664C_HEARTRATE: {
@@ -711,7 +766,43 @@ static int max32664c_channel_get(const struct device *dev, enum sensor_channel c
 		break;
 	}
 	case SENSOR_CHAN_MAX32664C_SKIN_CONTACT: {
-		val->val1 = data->report.scd_state;
+		switch (data->device_mode) {
+			case MAX32664C_OP_MODE_SCD: {
+				val->val1 = data->scd.scd_classifier;
+				val->val2 = 0;
+				break;
+			}
+#ifdef CONFIG_MAX32664C_USE_EXTENDED_REPORTS
+			case MAX32664C_OP_MODE_ALGO_AEC_EXT:
+			case MAX32664C_OP_MODE_ALGO_AGC_EXT: {
+				val->val1 = data->ext.scd_state;
+				val->val2 = 0;
+				break;
+			}
+#else
+			case MAX32664C_OP_MODE_ALGO_AEC:
+			case MAX32664C_OP_MODE_ALGO_AGC: {
+				val->val1 = data->report.scd_state;
+				val->val2 = 0;
+				break;
+			}
+#endif /* CONFIG_MAX32664C_USE_EXTENDED_REPORTS */
+			default: {
+				return -ENOTSUP;
+			}
+		}
+
+		break;
+	}
+	case SENSOR_CHAN_MAX32664C_ACTIVITY: {
+#ifdef CONFIG_MAX32664C_USE_EXTENDED_REPORTS
+		val->val1 = data->ext.activity_class;
+		val->val2 = 0;
+#else
+		val->val1 = data->report.activity_class;
+		val->val2 = 0;
+#endif /* CONFIG_MAX32664C_USE_EXTENDED_REPORTS */
+
 		break;
 	}
 	default: {
@@ -902,8 +993,8 @@ static int max32664c_attr_get(const struct device *dev, enum sensor_channel chan
 
 	switch ((int)attr) {
 	case SENSOR_ATTR_MAX32664C_OP_MODE: {
-		val->val1 = data->op_mode;
-		val->val2 = 0;
+		val->val1 = data->device_mode;
+		val->val2 = data->algo_mode;
 		break;
 	}
 	case SENSOR_ATTR_CONFIGURATION: {
@@ -927,6 +1018,16 @@ static int max32664c_attr_get(const struct device *dev, enum sensor_channel chan
 		}
 		break;
 	}
+	case SENSOR_ATTR_MAX32664C_STATUS: {
+		val->val1 = data->device_status;
+		val->val2 = 0;
+		break;
+	}
+	case SENSOR_ATTR_MAX32664C_STATUS: {
+		val->val1 = data->device_status;
+		val->val2 = 0;
+		break;
+	}
 	default: {
 		LOG_ERR("Unsupported sensor attribute!");
 		return -ENOTSUP;
@@ -978,21 +1079,15 @@ static int max32664c_init(const struct device *dev)
 		return -EINVAL;
 	}
 
-	data->op_mode = rx[1];
-	LOG_DBG("Mode: %x ", data->op_mode);
-	if (data->op_mode != 0) {
+	LOG_DBG("Application mode: %x ", rx[1]);
+	if (rx[1] != 0) {
 		return -EINVAL;
 	}
 
-	/* Read the firmware version */
-	tx[0] = 0xFF;
-	tx[1] = 0x03;
-	if (max32664c_i2c_transmit(dev, tx, 2, rx, 4, MAX32664C_DEFAULT_CMD_DELAY)) {
+	if (max32664c_read_fw_version(dev, &data->hub_ver[0], &data->hub_ver[1], &data->hub_ver[2])) {
 		return -EINVAL;
 	}
 
-	memcpy(data->hub_ver, &rx[1], 3);
-
 	LOG_DBG("Version: %d.%d.%d", data->hub_ver[0], data->hub_ver[1], data->hub_ver[2]);
 
 	if (max32664c_check_sensors(dev)) {
@@ -1079,6 +1174,7 @@ static int max32664c_pm_action(const struct device *dev, enum pm_device_action a
 		.spo2_calib = DT_INST_PROP(inst, spo2_calib),                                      \
 		.hr_config = DT_INST_PROP(inst, hr_config),                                        \
 		.spo2_config = DT_INST_PROP(inst, spo2_config),                                    \
+		.led_config = DT_INST_PROP(inst, led_config),                                      \
 		.use_max86141 = DT_INST_PROP(inst, use_max86141),                                  \
 		.use_max86161 = DT_INST_PROP(inst, use_max86161),                                  \
 		.motion_time = DT_INST_PROP(inst, motion_time),                                    \
diff --git a/drivers/sensor/adi/max32664c/max32664c.h b/drivers/sensor/adi/max32664c/max32664c.h
index facca74416d..7584cfcfb7f 100644
--- a/drivers/sensor/adi/max32664c/max32664c.h
+++ b/drivers/sensor/adi/max32664c/max32664c.h
@@ -164,6 +164,7 @@ struct max32664c_config {
 
 	uint8_t hr_config[2];
 	uint8_t spo2_config[2];
+	uint8_t led_config[3];
 	uint8_t led_current[3];           /**< Initial LED current in mA */
 	uint8_t min_integration_time_idx;
 	uint8_t min_sampling_rate_idx;
@@ -183,7 +184,10 @@ struct max32664c_data {
 	struct max32664c_report_t report;
 	struct max32664c_ext_report_t ext;
 
-	enum max32664c_device_mode op_mode; /**< Current device mode */
+	enum max32664c_device_mode device_mode; /**< Current device mode */
+	enum max32664c_algo_mode algo_mode; /**< Current algorithm mode */
+
+	uint32_t device_status;             /**< Current device status */
 
 	uint8_t motion_time;              /**< Motion time in milliseconds */
 	uint8_t motion_threshold;         /**< Motion threshold in milli-g */
diff --git a/drivers/sensor/adi/max32664c/max32664c_bl.c b/drivers/sensor/adi/max32664c/max32664c_bl.c
index 147c9aefe3b..5da370f64c9 100644
--- a/drivers/sensor/adi/max32664c/max32664c_bl.c
+++ b/drivers/sensor/adi/max32664c/max32664c_bl.c
@@ -331,7 +331,7 @@ int max32664c_bl_enter(const struct device *dev, const uint8_t *firmware, uint32
 
 int max32664c_bl_leave(const struct device *dev)
 {
-	uint8_t hub_ver[3];
+	uint8_t major, minor, patch;
 	uint8_t rx_buf[4] = {0};
 	const struct max32664c_config *config = dev->config;
 
@@ -371,13 +371,11 @@ int max32664c_bl_leave(const struct device *dev)
 	LOG_INF("MCU type: %u", rx_buf[1]);
 
 	/* Read the firmware version */
-	if (max32664c_app_i2c_read(dev, 0xFF, 0x03, rx_buf, 4)) {
+	if (max32664c_read_fw_version(dev, &major, &minor, &patch)) {
 		return -EINVAL;
 	}
 
-	memcpy(hub_ver, &rx_buf[1], 3);
-
-	LOG_INF("Version: %d.%d.%d", hub_ver[0], hub_ver[1], hub_ver[2]);
+	LOG_INF("Version: %d.%d.%d", major, minor, patch);
 
 	return 0;
 }
diff --git a/drivers/sensor/adi/max32664c/max32664c_init.c b/drivers/sensor/adi/max32664c/max32664c_init.c
index e65d2ec6af3..c7e46ba0d22 100644
--- a/drivers/sensor/adi/max32664c/max32664c_init.c
+++ b/drivers/sensor/adi/max32664c/max32664c_init.c
@@ -47,7 +47,7 @@ static int max32664c_set_spo2_coeffs(const struct device *dev)
 static int max32664c_write_config(const struct device *dev)
 {
 	uint8_t rx;
-	uint8_t tx[5];
+	uint8_t tx[6];
 	const struct max32664c_config *config = dev->config;
 	struct max32664c_data *data = dev->data;
 
@@ -96,6 +96,19 @@ static int max32664c_write_config(const struct device *dev)
 		return -EINVAL;
 	}
 
+	/* Configure LED */
+	tx[0] = 0x50;
+	tx[1] = 0x07;
+	tx[2] = 0x19;
+	tx[3] = config->led_config[0];
+	tx[4] = config->led_config[1];
+	tx[5] = config->led_config[2];
+	LOG_DBG("Configuring LED: 0x%02X%02X%02X", tx[3], tx[4], tx[5]);
+	if (max32664c_i2c_transmit(dev, tx, 6, &rx, 1, MAX32664C_DEFAULT_CMD_DELAY)) {
+		LOG_ERR("Can not configure LED!");
+		return -EINVAL;
+	}
+
 	/* Configure WHRM */
 	tx[0] = 0x50;
 	tx[1] = 0x07;
diff --git a/drivers/sensor/adi/max32664c/max32664c_worker.c b/drivers/sensor/adi/max32664c/max32664c_worker.c
index 4943c621919..8748ac344bf 100644
--- a/drivers/sensor/adi/max32664c/max32664c_worker.c
+++ b/drivers/sensor/adi/max32664c/max32664c_worker.c
@@ -73,6 +73,7 @@ static void max32664c_parse_and_push_raw(const struct device *dev)
 	struct max32664c_data *data = dev->data;
 	struct max32664c_raw_report_t report;
 
+	/* PG1 to 3 are used for PD1 */
 	report.PPG1 = ((uint32_t)(data->max32664_i2c_buffer[1]) << 16) |
 		       ((uint32_t)(data->max32664_i2c_buffer[2]) << 8) |
 		       data->max32664_i2c_buffer[3];
@@ -84,9 +85,15 @@ static void max32664c_parse_and_push_raw(const struct device *dev)
 		       data->max32664_i2c_buffer[9];
 
 	/* PPG4 to 6 are used for PD2 */
-	report.PPG4 = 0;
-	report.PPG5 = 0;
-	report.PPG6 = 0;
+	report.PPG4 = ((uint32_t)(data->max32664_i2c_buffer[10]) << 16) |
+		       ((uint32_t)(data->max32664_i2c_buffer[11]) << 8) |
+		       data->max32664_i2c_buffer[12];
+	report.PPG5 = ((uint32_t)(data->max32664_i2c_buffer[13]) << 16) |
+		       ((uint32_t)(data->max32664_i2c_buffer[14]) << 8) |
+		       data->max32664_i2c_buffer[15];
+	report.PPG6 = ((uint32_t)(data->max32664_i2c_buffer[16]) << 16) |
+		       ((uint32_t)(data->max32664_i2c_buffer[17]) << 8) |
+		       data->max32664_i2c_buffer[18];
 
 	report.acc.x =
 		((int16_t)(data->max32664_i2c_buffer[19]) << 8) | data->max32664_i2c_buffer[20];
@@ -171,6 +178,11 @@ static void max32664c_parse_and_push_ext_report(const struct device *dev)
 	report.reserved[0] = data->max32664_i2c_buffer[79];
 	report.reserved[1] = data->max32664_i2c_buffer[80];
 
+	data->device_status |= ((report.unreliable_orientation_flag & 0x01) << 4) |
+	                       ((report.sampling_rate_adj_flag & 0x01) << 3) |
+						   ((report.integration_time_adj_flag & 0x01) << 2) |
+						   (report.spo2_meas.state << 0);
+
 	max32664c_push_to_queue(&data->ext_report_queue, &report);
 }
 #else
@@ -207,6 +219,9 @@ static void max32664c_parse_and_push_report(const struct device *dev)
 	report.spo2_meas.state = data->max32664_i2c_buffer[43];
 	report.scd_state = data->max32664_i2c_buffer[44];
 
+	data->device_status |= (report.spo2_meas.state << 0);
+
+		LOG_DBG("Mode: %u", report->op_mode);
 	max32664c_push_to_queue(&data->report_queue, &report);
 }
 #endif /* CONFIG_MAX32664C_USE_EXTENDED_REPORTS */
@@ -290,7 +305,7 @@ void max32664c_worker(const struct device *dev)
 
 		uint8_t tx[2] = {0x12, 0x01};
 
-		switch (data->op_mode) {
+		switch (data->device_mode) {
 		case MAX32664C_OP_MODE_RAW: {
 			/* Get all samples to clear the FIFO */
 			max32664c_i2c_transmit(
@@ -350,6 +365,9 @@ void max32664c_worker(const struct device *dev)
 			break;
 		}
 #endif /* CONFIG_MAX32664C_USE_EXTENDED_REPORTS */
+		case MAX32664C_OP_MODE_SCD: {
+			/* Get all samples to clear the FIFO */
+		}
 		default: {
 			break;
 		}
diff --git a/dts/bindings/sensor/maxim,max32664c.yml b/dts/bindings/sensor/maxim,max32664c.yml
index 3f8c36c7749..d77c6dd407c 100644
--- a/dts/bindings/sensor/maxim,max32664c.yml
+++ b/dts/bindings/sensor/maxim,max32664c.yml
@@ -1,6 +1,3 @@
-title: |
-  MAX32664 biometric sensor hub
-
 description: |
   The MAX32664 is a ultra-low power biometric sensor hub.
 
@@ -157,3 +154,13 @@ properties:
       Algorithm configuration - LED and PD configuration for the SpO2 measurement.
       The first entry configures the IR channel, the second the red channel.
       The default corresponds to Table 15 in the HR and SpO2 User guide.
+
+  led-config:
+    type: uint8-array
+    default: [0x12, 0x30, 0x00]
+    description:
+      Algorithm configuration - LED configuration for HR and SpO2 measurement.
+      The first entry configures slot 1 and 2, the second configures slot 4 and 5 and
+      the last entry configures slot 5 and 6.
+      The default corresponds to Table 15 in the HR and SpO2 User guide.
+      Slot 1 = LED 1, Slot 2 = LED 2, Slot 3 = LED 3.
-- 
2.34.1

